<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://finger-bone.github.io/triangles-on-web/06/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Lighting - Introduction to WebGPU</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/color-brewer.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Introduction to WebGPU</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">2D Basics <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../01/" class="dropdown-item">Basic Setup</a>
</li>
                                    
<li>
    <a href="../02/" class="dropdown-item">Life Game</a>
</li>
                                    
<li>
    <a href="../03/" class="dropdown-item">Texture</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">3D Basics <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../04/" class="dropdown-item">Orthographic Projection</a>
</li>
                                    
<li>
    <a href="../05/" class="dropdown-item">Perspective Projection</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Lighting</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../07/" class="nav-link">WGSL</a>
                            </li>
                            <li class="navitem">
                                <a href="../08/" class="nav-link">3D Models</a>
                            </li>
                            <li class="navitem">
                                <a href="../09/" class="nav-link">Curves and Surfaces</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../05/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../07/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#triangles-on-web-ch6-lighting" class="nav-link">Triangles on Web Ch6 Lighting</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#ambient" class="nav-link">Ambient</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#diffuse" class="nav-link">Diffuse</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#specular" class="nav-link">Specular</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#putting-it-all-together" class="nav-link">Putting it all together</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#implementation" class="nav-link">Implementation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="triangles-on-web-ch6-lighting">Triangles on Web Ch6 Lighting</h1>
<p>Previously, we got the shape of our model right- with perspective projection. Now, we make the color right with lighting.</p>
<p>There are many lighting models- each tells how the fragment color is computed. The most common is Phong lighting model. It has 3 components: ambient, diffuse, and specular, which we will implement in this chapter.</p>
<p><img alt="Phong Lighting Model" src="image.png" /></p>
<h2 id="ambient">Ambient</h2>
<p>Ambient simply refers to the, well, ambient. It is the light that presents everywhere.</p>
<p>Ambient light will cause the object to have a constant light shad on it. And thus it renders the object with a constant color.</p>
<p>If we take a simple model, that the ambient light is white and the color is commensurate to the ambient light, then the color with ambient light taken into account is:</p>
<p>
<script type="math/tex; mode=display">
color = I \cdot albedo
</script>
</p>
<p>
<script type="math/tex; mode=display">
I = k_{\text{ambient}} \cdot I_{\text{ambient}}
</script>
</p>
<p>Where <script type="math/tex">I_{\text{ambient}}</script> is the intensity of the ambient light. In computer graphics, the intensity of light usually just use a unit of one, without any unit. <script type="math/tex"> I </script> is the intensity of the light considering all factors, only ambient light in this case.</p>
<p>
<script type="math/tex"> albedo </script> is just a fancy word for the color of the object if it is not illuminated by any light.</p>
<p>
<script type="math/tex"> k_{\text{ambient}} </script> is a  factor that denotes the reflectivity of the object. You can take arbitrary values, but usually, it is taken as 1.0.</p>
<p>Normally, we can take <script type="math/tex">I_{\text{ambient}} = 0.3</script>.</p>
<h2 id="diffuse">Diffuse</h2>
<p>However, there is not only ambient light that is scattered everywhere- usually, there are also directed light sources. The light will shad on the object, reflected off its surface and reach the camera (more detailed lighting will just be ignored, we only consider reflection and the first reflection).</p>
<p>In physics, we know that if a light reflects off a surface, there are two cases- if the surface is smooth, it is a specular reflection, where the reflection is sharp and clear, with reflected light following the law of reflection. If the surface is rough, because each surface can be viewed as smaller smooth surfaces of many different angles, the light will be reflected in all directions, and the reflection is called diffuse reflection.</p>
<p>In Phong lighting model, both reflections are considered, albeit this is not the case in real life.</p>
<p>Diffuse reflection follows the Lambert cosine law. The law states that the intensity of the light reflected off a surface is proportional to the cosine of the angle between the light source and the surface normal.</p>
<p>That is, if the unit normal vector is <script type="math/tex"> \vec{n} </script>, a light with <script type="math/tex"> \vec{l} </script> and intensity <script type="math/tex"> I_{\text{diffuse}} </script>, the intensity of the light reflected off the surface is:</p>
<p>
<script type="math/tex; mode=display">
I_{\text{diffuse}} = k_{\text{diffuse}} \cdot I_{\text{diffuse}} \cdot \max(0, \vec{n} \cdot \vec{l})
</script>
</p>
<h2 id="specular">Specular</h2>
<p>We also consider the specular reflection. The specular reflection denotes the light that is directly reflected to the camera.</p>
<p>If we have a light that is reflected off a surface with the intensity <script type="math/tex"> I_{\text{specular}} </script>, the intensity of the light perceived by the camera is determined by the phong reflection model, with,</p>
<p>
<script type="math/tex; mode=display">
I_{\text{specular}} = k_{\text{specular}} \cdot I_{\text{specular}} \cdot \max(0, \vec{r} \cdot \vec{v})^{\alpha}
</script>
</p>
<p>Where <script type="math/tex"> \vec{r} </script> is the reflection of the light, <script type="math/tex"> \vec{v} </script> is the vector from the fragment to the camera, and <script type="math/tex"> \alpha </script> is the shininess of the object, or say, how rough the highlight is. The higher the value, the more concentrated the highlight is, and vice versa.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Now, we have all the components of the Phong lighting model. We can put it all together to get the final color of the fragment.</p>
<p>First off, for a point at <script type="math/tex"> \vec{p} </script> (the world axis), the normal vector of the primitive at this point being <script type="math/tex"> \vec{n} </script>, the camera position being <script type="math/tex"> \vec{v} </script>, and the light position being <script type="math/tex"> \vec{l} </script>.</p>
<p>Now, let's first consider how we can get all the vectors.</p>
<p>
<script type="math/tex"> \vec{p} </script> is directly given by the model.</p>
<p>
<script type="math/tex"> \vec{n} </script> can be calculated by the cross product of the two edges of the triangle, and then normalized. So in vertex shader, we pass both the normal vector and the position of the vertex.</p>
<p>
<script type="math/tex"> \vec{v} </script> is simply the camera position minus the position of the fragment.</p>
<p>
<script type="math/tex"> \vec{l} </script> is the light position minus the position of the fragment. This is determined by the light source we want.</p>
<p>
<script type="math/tex"> \vec{r} </script> is the reflection of the light, which can be calculated by the formula:</p>
<p>
<script type="math/tex; mode=display">
\vec{r} = 2 \cdot \vec{n} \cdot (\vec{n} \cdot \vec{l}) - \vec{l}
</script>
</p>
<p>Now, we can calculate the intensity of the light by the formula:</p>
<p>
<script type="math/tex; mode=display">
I_{\text{light}} = I_{\text{ambient}} + I_{\text{diffuse}} + I_{\text{specular}}
</script>
</p>
<p>And the final color of the fragment is:</p>
<p>
<script type="math/tex; mode=display">
color = I_{\text{light}} \cdot albedo
</script>
</p>
<p>For each component of the light,</p>
<p>
<script type="math/tex; mode=display">
I_{\text{ambient}} = k_{\text{ambient}} \cdot I_{\text{ambient}}
</script>
</p>
<p>
<script type="math/tex; mode=display">
I_{\text{diffuse}} = k_{\text{diffuse}} \cdot I_{\text{diffuse}} \cdot \max(0, \vec{n} \cdot \vec{l})
</script>
</p>
<p>
<script type="math/tex; mode=display">
I_{\text{specular}} = k_{\text{specular}} \cdot I_{\text{specular}} \cdot \max(0, \vec{r} \cdot \vec{v})^{\alpha}
</script>
</p>
<h2 id="implementation">Implementation</h2>
<p>Now let's add a point light source to our cube.</p>
<p>First, we need to calculate the normal vector, then pass it to the vertex shader.</p>
<pre><code class="language-typescript">
const get_shader = async (device: GPUDevice): Promise&lt;GPUShaderModule&gt; =&gt; {
    return device.createShaderModule({
        label: &quot;sm&quot;,
        code: `
        @group(0) @binding(0) var&lt;uniform&gt; projection: mat4x4&lt;f32&gt;;
        @group(0) @binding(1) var&lt;uniform&gt; angle: f32;

        struct VertexOutput {
            @builtin(position) pos: vec4f,
            @location(0) @interpolate(flat) face: u32,
        };

        @vertex
        fn vertexMain(@location(0) position: vec3f, @location(1) norm: vec3f, @builtin(vertex_index) vertexIndex: u32) -&gt; VertexOutput {

            let rotation = mat3x3&lt;f32&gt;(
                vec3&lt;f32&gt;(1.0, 0.0, 0.0),
                vec3&lt;f32&gt;(0.0, cos(angle), sin(angle)),
                vec3&lt;f32&gt;(0.0, -sin(angle), cos(angle)),
            );

            let rotated = vec4&lt;f32&gt;(rotation * (position - vec3f(0.4, 0.4, 0.0)), 1.0);
            var projected = projection * (rotated - vec4&lt;f32&gt;(0.0, 0.0, ${f}, 0.0));
            let final_position = vec4&lt;f32&gt;(projected.xy, 1.0 - rotated.z, projected.w);

            var output = VertexOutput(final_position, vertexIndex / 6);
            return output;
        }

        struct FragmentOutput {
            @location(0) color: vec4&lt;f32&gt;,
        };

        @fragment
        fn fragmentMain(input: VertexOutput) -&gt; FragmentOutput {
            var output = FragmentOutput(vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0));
            if (input.face == 0u) {
                output.color = vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
            } else if (input.face == 1u) {
                output.color = vec4&lt;f32&gt;(0.0, 1.0, 0.0, 1.0);
            } else if (input.face == 2u) {
                output.color = vec4&lt;f32&gt;(0.0, 0.0, 1.0, 1.0);
            } else if (input.face == 3u) {
                output.color = vec4&lt;f32&gt;(1.0, 1.0, 0.0, 1.0);
            } else if (input.face == 4u) {
                output.color = vec4&lt;f32&gt;(1.0, 0.0, 1.0, 1.0);
            } else {
                output.color = vec4&lt;f32&gt;(0.0, 1.0, 1.0, 1.0);
            }
            return output;
        }
        `,
    })
}

const get_vertices = (device: GPUDevice): [GPUBuffer, GPUVertexBufferLayout] =&gt; {
    // cube
    // use triangle
    const vertices = new Float32Array([
        // xy
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 0.0,

        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        1.0, 1.0, 0.0,

        1.0, 0.0, 1.0,
        0.0, 1.0, 1.0,
        0.0, 0.0, 1.0,

        1.0, 0.0, 1.0,
        0.0, 1.0, 1.0,
        1.0, 1.0, 1.0,
        // yz
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0,

        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0,
        0.0, 1.0, 1.0,

        1.0, 1.0, 0.0,
        1.0, 0.0, 1.0,
        1.0, 0.0, 0.0,

        1.0, 1.0, 0.0,
        1.0, 0.0, 1.0,
        1.0, 1.0, 1.0,
        // zx
        0.0, 0.0, 1.0,
        1.0, 0.0, 0.0,
        1.0, 0.0, 1.0,

        0.0, 0.0, 1.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 0.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 1.0, 1.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        0.0, 1.0, 0.0,
    ]).map((v) =&gt; v * 0.5 - 0.25);

    const primitiveCount = vertices.length / 9;
    const verticesWithNormals = new Float32Array(primitiveCount * 6 * 3);
    const cross = (a: number[], b: number[]): number[] =&gt; {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0],
        ]
    }
    for (let i = 0; i &lt; primitiveCount; i++) {
        const a = [vertices[i * 9 + 0], vertices[i * 9 + 1], vertices[i * 9 + 2]];
        const b = [vertices[i * 9 + 3], vertices[i * 9 + 4], vertices[i * 9 + 5]];
        const c = [vertices[i * 9 + 6], vertices[i * 9 + 7], vertices[i * 9 + 8]];
        const ab = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];
        const ac = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];
        const normal = cross(ab, ac);
        const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
        normal[0] /= length;
        normal[1] /= length;
        normal[2] /= length;
        for (let j = 0; j &lt; 3; j++) {
            verticesWithNormals[i * 18 + j * 6 + 0] = vertices[i * 9 + j * 3 + 0];
            verticesWithNormals[i * 18 + j * 6 + 1] = vertices[i * 9 + j * 3 + 1];
            verticesWithNormals[i * 18 + j * 6 + 2] = vertices[i * 9 + j * 3 + 2];
            verticesWithNormals[i * 18 + j * 6 + 3] = normal[0];
            verticesWithNormals[i * 18 + j * 6 + 4] = normal[1];
            verticesWithNormals[i * 18 + j * 6 + 5] = normal[2];
        }
    }

    const layout: GPUVertexBufferLayout = {
        arrayStride: 3 * 4 * 2,
        attributes: [{
            format: &quot;float32x3&quot;,
            offset: 0,
            shaderLocation: 0,
        }, {
            format: &quot;float32x3&quot;,
            offset: 3 * 4,
            shaderLocation: 1
        }]
    }
    const buffer = device.createBuffer({
        size: verticesWithNormals.length * 4,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    })
    device.queue.writeBuffer(buffer, 0, verticesWithNormals.buffer);
    return [buffer, layout];
}
</code></pre>
<p>Then we simply put norm vector into the output of the vertex shader, asking a linear interpolation of the norm vector. In addition, we also need the real position of the vertex for calculating lighting.</p>
<pre><code class="language-wgsl">struct VertexOutput {
    @builtin(position) pos: vec4f,
    @location(0) @interpolate(flat) face: u32,
    @location(1) @interpolate(linear) real_position: vec3f,
    @location(2) @interpolate(linear) normal: vec3f,
};

@vertex
fn vertexMain(@location(0) position: vec3f, @location(1) norm: vec3f, @builtin(vertex_index) vertexIndex: u32) -&gt; VertexOutput {

    let rotation = mat3x3&lt;f32&gt;(
        vec3&lt;f32&gt;(1.0, 0.0, 0.0),
        vec3&lt;f32&gt;(0.0, cos(angle), sin(angle)),
        vec3&lt;f32&gt;(0.0, -sin(angle), cos(angle)),
    );

    let rotated = vec4&lt;f32&gt;(rotation * (position - vec3f(0.4, 0.4, 0.0)), 1.0);
    var projected = projection * (rotated - vec4&lt;f32&gt;(0.0, 0.0, ${f}, 0.0));
    let final_position = vec4&lt;f32&gt;(projected.xy, 1.0 - rotated.z, projected.w);

    var output = VertexOutput(final_position, vertexIndex / 6, rotation * position, rotation * norm);
    return output;
}
</code></pre>
<p>Now, in the fragment shader, we have our normal vector and positional vector. We can calculate the light intensity by the formula above.</p>
<p>First, the albedo,</p>
<pre><code class="language-wgsl">@fragment
fn fragmentMain(input: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    var output = vec4&lt;f32&gt;(0.3, 0.3, 0.3, 1.0);
    return output;
}
</code></pre>
<p>Then calculate all the vectors. Here we use a point light source.</p>
<pre><code class="language-wgsl">@group(0) @binding(0) var&lt;uniform&gt; projection: mat4x4&lt;f32&gt;;
@group(0) @binding(1) var&lt;uniform&gt; angle: f32;

struct VertexOutput {
    @builtin(position) pos: vec4f,
    @location(0) @interpolate(flat) face: u32,
    @location(1) @interpolate(linear) real_position: vec3f,
    @location(2) @interpolate(linear) normal: vec3f,
};

@vertex
fn vertexMain(@location(0) position: vec3f, @location(1) norm: vec3f, @builtin(vertex_index) vertexIndex: u32) -&gt; VertexOutput {

    let rotation = mat3x3&lt;f32&gt;(
        vec3&lt;f32&gt;(1.0, 0.0, 0.0),
        vec3&lt;f32&gt;(0.0, cos(angle), sin(angle)),
        vec3&lt;f32&gt;(0.0, -sin(angle), cos(angle)),
    );
    let rotated = vec4&lt;f32&gt;(rotation * (position - vec3f(0.3, 0.3, 0.0)), 1.0);
    var projected = projection * (rotated - vec4&lt;f32&gt;(0.0, 0.0, ${f}, 0.0));
    let final_position = vec4&lt;f32&gt;(projected.xy, 1.0 - rotated.z, projected.w);

    var output = VertexOutput(final_position, vertexIndex / 6, rotated.xyz, rotation * norm);
    return output;
}

@fragment
fn fragmentMain(input: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {

    let light_source = vec3&lt;f32&gt;(-1.0, 0.0, -5.0);
    let l = normalize(light_source - input.real_position);
    let n = normalize(input.normal);
    let r = reflect(-l, n);
    let camera = vec3&lt;f32&gt;(0.0, 0.0, -1.0);
    let v = normalize(camera - input.real_position);
    let spec = pow(max(dot(r, v), 0.0), 32.0) * 0.8;
    let diff = max(dot(-n, l), 0.0) * 0.4;
    let amb = 0.2;
    let albedo = vec3&lt;f32&gt;(1.0, 1.0, 1.0);
    let color = albedo * min(amb + diff + spec, 1.0);
    return vec4&lt;f32&gt;(color, 1.0);
}
</code></pre>
<p>Please note that, we have not yet set the position of the camera previously- since we did not do the scaling based on the field of view, so you can basically choose any position of the camera. Here we choose (0, 0, -1).</p>
<p>Also, some negative-positive signs were changed based since now <code>l</code> is the vector points to the source from the fragment.</p>
<p>Now, you should see a cube with lighting. However- you may encounter an issue, that some primitives are properly lit, while some are not. This is because the normal vector has two directions. When creating hte vertices, you should make sure that the normal vector is pointing outwards. Previously shown vertices and cross product are correct.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
