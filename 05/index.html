<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://finger-bone.github.io/triangles-on-web/05/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Perspective Projection - Introduction to WebGPU</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/color-brewer.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Introduction to WebGPU</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">2D Basics <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../01/" class="dropdown-item">Basic Setup</a>
</li>
                                    
<li>
    <a href="../02/" class="dropdown-item">Life Game</a>
</li>
                                    
<li>
    <a href="../03/" class="dropdown-item">Texture</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">3D Basics <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../04/" class="dropdown-item">Orthographic Projection</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Perspective Projection</a>
</li>
                                    
<li>
    <a href="../06/" class="dropdown-item">Lighting</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../07/" class="nav-link">WGSL</a>
                            </li>
                            <li class="navitem">
                                <a href="../08/" class="nav-link">3D Models</a>
                            </li>
                            <li class="navitem">
                                <a href="../09/" class="nav-link">Curves and Surfaces</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../04/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../06/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#triangles-on-web-ch5-perspective-projection" class="nav-link">Triangles on Web Ch5 Perspective Projection</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#clip-space" class="nav-link">Clip Space</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#camera-system" class="nav-link">Camera System</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#perspective-projection" class="nav-link">Perspective Projection</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#show-the-cube-in-perspective" class="nav-link">Show the Cube in Perspective</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="triangles-on-web-ch5-perspective-projection">Triangles on Web Ch5 Perspective Projection</h1>
<p>In this chapter, we learn about perspective projection, which is the most common way to render 3D objects.</p>
<p>In this chapter, we will also learn about the clip space of the WebGPU, the camera system and the perspective projection.</p>
<h2 id="clip-space">Clip Space</h2>
<p>We previously learnt that the normalized device coordinates (NDC) is adopted in the WebGPU, but how exactly does NDC work?</p>
<p>During rendering, first off, the points are four dimensional, and the fourth dimension is the homogeneous coordinate, which is used to perform perspective division, a topic we will discuss later. Simply, the renderer transforms four-dimensional points to three-dimensional points by dividing the first three dimensions by the fourth dimension. That is, <script type="math/tex">(x, y, z, w)</script> to <script type="math/tex"> (\frac{x}{w}, \frac{y}{w}, \frac{z}{w})</script>.</p>
<p>After perspective division, the points are in the clip space. Which means, the points exceeds the range of zero to one on x or y axis will be removed, and the points with negative z value or z value larger than one (after these values are divided by w) will be removed.</p>
<p>Then, the vertices are converted into primitives, and sends each pixel to the fragment shader for rendering.</p>
<p>If you enabled depth testing, the render will take the z-axis as the depth by default- but caution that points with z smaller than zero or larger than one will be removed, so you need to get around the depth a bit.</p>
<p>That is, you can change our previous code into this one with same result- instead of manually calculating the depth, we just use native z-axis as the depth.</p>
<pre><code class="language-wgsl">@group(0) @binding(0) var&lt;uniform&gt; projection: mat3x2&lt;f32&gt;;
@group(0) @binding(1) var&lt;uniform&gt; angle: f32;

struct VertexOutput {
    @builtin(position) pos: vec4f,
    @location(0) @interpolate(flat) face: u32,
    @location(1) depth: f32,
};

@vertex
fn vertexMain(@location(0) position: vec3f, @builtin(vertex_index) vertexIndex: u32) -&gt; VertexOutput {

    let rotation = mat3x3&lt;f32&gt;(
        vec3&lt;f32&gt;(cos(angle), 0.0, sin(angle)),
        vec3&lt;f32&gt;(0.0, 1.0, 0.0),
        vec3&lt;f32&gt;(-sin(angle), 0.0, cos(angle))
    );

    let rotated = rotation * position;

    let projected = projection * rotated;
    let final_position = vec4&lt;f32&gt;(projected, rotated.z * 0.25 + 0.25, 1.0);
    let depth = rotated.z * 0.5 + 0.5;

    var output = VertexOutput(final_position, vertexIndex / 6, depth);
    return output;
}

struct FragmentOutput {
    @location(0) color: vec4&lt;f32&gt;,
    // @builtin(frag_depth) depth: f32,
};

@fragment
fn fragmentMain(input: VertexOutput) -&gt; FragmentOutput {
    var output = FragmentOutput(vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0));
    if (input.face == 0u) {
        output.color = vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
    } else if (input.face == 1u) {
        output.color = vec4&lt;f32&gt;(0.0, 1.0, 0.0, 1.0);
    } else if (input.face == 2u) {
        output.color = vec4&lt;f32&gt;(0.0, 0.0, 1.0, 1.0);
    } else if (input.face == 3u) {
        output.color = vec4&lt;f32&gt;(1.0, 1.0, 0.0, 1.0);
    } else if (input.face == 4u) {
        output.color = vec4&lt;f32&gt;(1.0, 0.0, 1.0, 1.0);
    } else {
        output.color = vec4&lt;f32&gt;(0.0, 1.0, 1.0, 1.0);
    }
    return output;
}
</code></pre>
<h2 id="camera-system">Camera System</h2>
<p>A camera is something that captures the scene, and the camera system is a system that simulates the camera in the 3D world.</p>
<p>In the previous chapter, we used the rotation matrix to rotate the object. Of course, you can also translate the object by adding a translation matrix. Of course, such things are useful, but more often, we take a different approach- albeit the same result- by moving the camera instead of the object.</p>
<p>A camera usually has its position, direction and field of view. The position is the position of the camera, the direction is the direction the camera is facing, and the field of view is the angle of the camera's view, that is, how wide the camera can see.</p>
<p><img alt="Field of View" src="image.png" /></p>
<p>The field of view is usually measured in how large the screen the camera can see at the distance of one unit.</p>
<p>After introducing the camera, instead of using the raw points to render, we use the points relative to the camera.</p>
<p>This transformation is called the view transformation, which is actually three steps, translation, rotation and scaling.</p>
<h3 id="translation">Translation</h3>
<p>It's simple, the translated position is simply the original position minus the camera's position.</p>
<p>
<script type="math/tex; mode=display">
r_{\text{translated}} = r_{\text{original}} - r_{\text{camera}}
</script>
</p>
<h3 id="rotation">Rotation</h3>
<p>The rotation is a bit more complicated. On the simple side, you just need to rotated the <script type="math/tex">r_{\text{translated}}</script> by the inverse of the camera's rotation. By complicated, it is that you need to determine a rotation matrix that inverts the camera's rotation matrix.</p>
<p>This depends on how you describe the rotation. A typical way would be the Euler angles- which implies that the rotation is done three times that are orthogonal between each two processes.</p>
<p>The most common way is the ZYX order, it contains three rotations. Please note that as the object rotates, there is something called local axis and global axis. The local axis is the axis of the object, which follows the same rotation as the object, while the global axis is the axis of the world, which is fixed. At first, the local axis is the same as the global axis, but as the object rotates, the local axis changes.</p>
<p>The following </p>
<ol>
<li>Yaw, the object rotates around the local z-axis.</li>
<li>Pitch, the object rotates around the local y-axis.</li>
<li>Roll, the object rotates around the local x-axis.</li>
</ol>
<p>If the angles are respectively <script type="math/tex">\alpha</script>, <script type="math/tex">\beta</script> and <script type="math/tex">\gamma</script>, the rotation matrix is the product of the three rotation matrices.</p>
<p>If we suppose the rotation matrix is <script type="math/tex">R</script>, that is, for the camera,</p>
<p>
<script type="math/tex; mode=display">
d_{\text{camera}} = R \cdot (0, 0, 1)
</script>
</p>
<p>Then for the object, the rotation matrix is <script type="math/tex">R^{-1}</script>, that is,</p>
<p>
<script type="math/tex; mode=display">
r_{\text{rotated}} = R^{-1} \cdot r_{\text{translated}}
</script>
</p>
<h3 id="scaling">Scaling</h3>
<p>The scaling is simple, remember the field of view? By default, our field of view is two. So if we want a view of width <script type="math/tex">f_w</script> and of height <script type="math/tex">f_h</script>,</p>
<p>
<script type="math/tex; mode=display">
r_{\text{scaled}} = (\frac{r_{\text{rotated}}}{2 * f_w}, \frac{r_{\text{rotated}}}{2 * f_h}, r_{\text{rotated}})
</script>
</p>
<h2 id="perspective-projection">Perspective Projection</h2>
<p>Now we know what a three-dimensional point should be transformed based on a camera, now we need to project the three-dimensional point to the two-dimensional scene the camera is facing.</p>
<p>We already did that via orthographic projection, but it just sees not real- the reason was already addressed by artists in the Renaissance, that is, the perspective. Again, we do not explain what is perspective- we only talks about the math of it.</p>
<h3 id="perspective-division">Perspective Division</h3>
<p>We know that parallel lines should merge into one point in the distance, and the point is called the vanishing point. If the parallel lines rotates along the direct-up axis, the vanishing point will move along the x-axis, this is called the view horizon.</p>
<p><img alt="Vanishing Point" src="image-1.jpg" /></p>
<p>This is from the view of lines. However, in computer graphics, we usually use the point-wise view of perspective.</p>
<p>That is, there is a global vanishing point, where it radiates straight lines. There also exists a screen before the vanishing point, and then the camera looks at the screen. For a point in the 3D space, it's 2D projection on the screen is the intersection of the screen and a straight line that goes through the point and the vanishing point.</p>
<p>Let's suppose the horizon is at the distance of <script type="math/tex">f</script>, relative to the camera, and stays at <script type="math/tex">y_{\text{horizon}}</script> on the screen, which is also relative to the camera. </p>
<p>Now, let's consider a point <script type="math/tex">(x, y, z)</script>, relative to the camera, we need to project it onto the screen, where z is zero. That is, we want to ask for <script type="math/tex">(x_s, y_s, 0)</script>, a straight line determined by <script type="math/tex">(x, y, z)</script> and <script type="math/tex">(x_s, y_s, 0)</script> goes right through the <script type="math/tex">(0, y_{\text{horizon}}, f)</script>.</p>
<p>So, we have</p>
<p>
<script type="math/tex; mode=display">
\frac{x_s}{x} = \frac{f}{f - z}
</script>
</p>
<p>and,</p>
<p>
<script type="math/tex; mode=display">
\frac{y_s - y_\text{horizon}}{y - y_\text{horizon}} = \frac{f}{f - z}
</script>
</p>
<p>More commonly we take <script type="math/tex">y_{\text{horizon}}</script> as zero,</p>
<p>
<script type="math/tex; mode=display">
\frac{y_s}{y} = \frac{f}{f - z}
</script>
</p>
<p>This is called the perspective division, and the <script type="math/tex">f</script> is the focal length of the camera.</p>
<p>Please note that, this only considers the further-smaller role along the z-axis rotation. Only x-axis and y-axis has a perspective division, the z-axis does not.</p>
<p>If you also want z-axis to have a perspective division, there are many more complex methods, which are too much for this chapter and we won't talk about it.</p>
<h3 id="using-homogeneous-coordinates-for-perspective-division">Using Homogeneous Coordinates for Perspective Division</h3>
<p>Now, as you many have seen, we need division in the perspective division. However, division is bad because we prefer multiplication or addition. A way to get around is to use homogeneous coordinates.</p>
<p>We already talked about how homogeneous coordinates work in the previous chapter, <script type="math/tex">(x, y, z, w)</script> is the same as <script type="math/tex">(\frac{x}{w}, \frac{y}{w}, \frac{z}{w})</script>.</p>
<p>So, instead of doing division, we can use a matrix that manipulates the fourth dimension to do the division for us.</p>
<p>That is, if we take the vector relative to the vanish point as <script type="math/tex">r_{\text{vanish}} = r_{\text{rotated}} - (0, y_{\text{horizon}}, f)</script>, we can use the following matrix to do the perspective division,</p>
<p>
<script type="math/tex; mode=display">
r_{\text{projected vanish}} = \begin{bmatrix}
-f & 0 & 0 & 0 \\
0 & -f & 0 & 0 \\
0 & 0 & -f & 0 \\
0 & 0 & 1 & 0
\end{bmatrix} \cdot r_{\text{vanish}}
</script>
</p>
<p>Note that we ignores z-axis value all together- it is a fixed value. Because it represents the depth of the point. Technically, the projected z-axis should stay <script type="math/tex">-f</script> based on the coordinate system with vanishing point as origin- but it doesn't matter.</p>
<p>If we expand the matrix multiplication, we get,</p>
<p>
<script type="math/tex; mode=display">
(-f \cdot x, -f \cdot y, -f (z-f), z - f) = \begin{bmatrix}
-f & 0 & 0 & 0 \\
0 & -f & 0 & 0 \\
0 & 0 & -f & 0 \\
0 & 0 & 1 & 0
\end{bmatrix} \cdot (x, y, z - f, 1)
</script>
</p>
<p>After converting the homogeneous coordinates back to the Cartesian coordinates, we get,</p>
<p>
<script type="math/tex; mode=display">
(-\frac{f \cdot x}{z - f}, -\frac{f \cdot y}{z - f}, -f)
</script>
</p>
<p>Which is exactly the perspective division we want.</p>
<h2 id="show-the-cube-in-perspective">Show the Cube in Perspective</h2>
<p>Previously, we have,</p>
<pre><code class="language-wgsl">@group(0) @binding(0) var&lt;uniform&gt; projection: mat3x2&lt;f32&gt;;
@group(0) @binding(1) var&lt;uniform&gt; angle: f32;

struct VertexOutput {
    @builtin(position) pos: vec4f,
    @location(0) @interpolate(flat) face: u32,
};

@vertex
fn vertexMain(@location(0) position: vec3f, @builtin(vertex_index) vertexIndex: u32) -&gt; VertexOutput {

    let rotation = mat3x3&lt;f32&gt;(
        vec3&lt;f32&gt;(cos(angle), 0.0, sin(angle)),
        vec3&lt;f32&gt;(0.0, 1.0, 0.0),
        vec3&lt;f32&gt;(-sin(angle), 0.0, cos(angle))
    );

    let rotated = rotation * position;

    let projected = projection * rotated;
    let depth = rotated.z * 0.25 + 0.25;
    let final_position = vec4&lt;f32&gt;(projected, depth, 1.0);

    var output = VertexOutput(final_position, vertexIndex / 6);
    return output;
}

struct FragmentOutput {
    @location(0) color: vec4&lt;f32&gt;,
};

@fragment
fn fragmentMain(input: VertexOutput) -&gt; FragmentOutput {
    var output = FragmentOutput(vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0));
    if (input.face == 0u) {
        output.color = vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
    } else if (input.face == 1u) {
        output.color = vec4&lt;f32&gt;(0.0, 1.0, 0.0, 1.0);
    } else if (input.face == 2u) {
        output.color = vec4&lt;f32&gt;(0.0, 0.0, 1.0, 1.0);
    } else if (input.face == 3u) {
        output.color = vec4&lt;f32&gt;(1.0, 1.0, 0.0, 1.0);
    } else if (input.face == 4u) {
        output.color = vec4&lt;f32&gt;(1.0, 0.0, 1.0, 1.0);
    } else {
        output.color = vec4&lt;f32&gt;(0.0, 1.0, 1.0, 1.0);
    }
    return output;
}
</code></pre>
<p>Now, we need to change how <code>let projected = projection * rotated;</code> works, rotated is a three dimensional vector, and we need to convert it to a four dimensional vector. We can do this by adding a one at the end of the vector.</p>
<pre><code class="language-wgsl">let rotated = vec4&lt;f32&gt;(rotation * position, 1.0);
</code></pre>
<p>Then, we need to change the projection matrix. We change the projection matrix into a four by four matrix,</p>
<pre><code class="language-wgsl">@group(0) @binding(0) var&lt;uniform&gt; projection: mat4x4&lt;f32&gt;;
</code></pre>
<p>Then do our previously said transformation. Please note the depth calculation, where we use world z-axis (you haven't forgot world axis, right?) to calculate the depth.</p>
<pre><code class="language-wgsl">@group(0) @binding(0) var&lt;uniform&gt; projection: mat4x4&lt;f32&gt;;
@group(0) @binding(1) var&lt;uniform&gt; angle: f32;

struct VertexOutput {
    @builtin(position) pos: vec4f,
    @location(0) @interpolate(flat) face: u32,
};

@vertex
fn vertexMain(@location(0) position: vec3f, @builtin(vertex_index) vertexIndex: u32) -&gt; VertexOutput {

    let rotation = mat3x3&lt;f32&gt;(
        vec3&lt;f32&gt;(cos(angle), 0.0, sin(angle)),
        vec3&lt;f32&gt;(0.0, 1.0, 0.0),
        vec3&lt;f32&gt;(-sin(angle), 0.0, cos(angle))
    );

    let rotated = vec4&lt;f32&gt;(rotation * position, 1.0);
    var projected = projection * (rotated - vec4&lt;f32&gt;(0.0, 0.0, 2.0, 0.0));
    let final_position = vec4&lt;f32&gt;(projected.xy, 1.0 - rotated.z, projected.w);

    var output = VertexOutput(final_position, vertexIndex / 6);
    return output;
}

struct FragmentOutput {
    @location(0) color: vec4&lt;f32&gt;,
};

@fragment
fn fragmentMain(input: VertexOutput) -&gt; FragmentOutput {
    var output = FragmentOutput(vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0));
    if (input.face == 0u) {
        output.color = vec4&lt;f32&gt;(1.0, 0.0, 0.0, 1.0);
    } else if (input.face == 1u) {
        output.color = vec4&lt;f32&gt;(0.0, 1.0, 0.0, 1.0);
    } else if (input.face == 2u) {
        output.color = vec4&lt;f32&gt;(0.0, 0.0, 1.0, 1.0);
    } else if (input.face == 3u) {
        output.color = vec4&lt;f32&gt;(1.0, 1.0, 0.0, 1.0);
    } else if (input.face == 4u) {
        output.color = vec4&lt;f32&gt;(1.0, 0.0, 1.0, 1.0);
    } else {
        output.color = vec4&lt;f32&gt;(0.0, 1.0, 1.0, 1.0);
    }
    return output;
}
</code></pre>
<p>Then change the projection matrix,</p>
<pre><code class="language-typescript">const f = 2;
const projectionMatrix = new Float32Array([
    -f, 0, 0, 0,
    0, -f, 0, 0,
    0, 0, 0, -f,
    0, 0, 1, 0,
]);
const projectionBuffer = device.createBuffer({
    size: 4 * 4 * 4,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});
</code></pre>
<p>Now you should see a very realistic, nice cube in perspective. Adding with our previous chapter, you can rotate the cube.</p>
<p>You can also move the cube with,</p>
<pre><code class="language-wgsl">let rotated = vec4&lt;f32&gt;(rotation * (position - vec3f(0.4, 0.4, 0.0)), 1.0);
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
